<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Memoet on Go slowly</title>
    <link>https://manhtai.github.io/tags/memoet/</link>
    <description>Recent content in Memoet on Go slowly</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 May 2021 10:54:27 +0700</lastBuildDate>
    
        <atom:link href="https://manhtai.github.io/tags/memoet/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Maintain Ecto many-to-many associations in Phoenix template</title>
      <link>https://manhtai.github.io/posts/ecto-many-to-many-assoc/</link>
      <pubDate>Sun, 30 May 2021 10:54:27 +0700</pubDate>
      
      <guid>https://manhtai.github.io/posts/ecto-many-to-many-assoc/</guid>
      <description>&lt;p&gt;While building Today collection feature for &lt;a href=&#34;https://github.com/memoetapp/memoet&#34;&gt;Memoet&lt;/a&gt;, I encounter a
many-to-many relation problem in Ecto: how to edit the relationship using
only Phoenix template form.&lt;/p&gt;
&lt;h2 id=&#34;the-models&#34;&gt;The models&lt;/h2&gt;
&lt;p&gt;We got a Deck model, which contains many notes of the same topic, as follow:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;schema &amp;quot;decks&amp;quot; do
  field(:name, :string)
  has_many(:notes, Note)

  timestamps()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we create a new Collection model, which will contains many decks for us to
learn all notes in those decks at once, aka cross-deck learning:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;schema &amp;quot;collections&amp;quot; do
  field(:name, :string)

  timestamps()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now a collection will contains many decks, and a deck may belong to many
collections, so that is a typical many-to-many relation. We define a mediate
model for that:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;schema &amp;quot;decks_collections&amp;quot; do
  belongs_to(:collection, Collection)
  belongs_to(:deck, Deck)

  timestamps()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will work mostly from the collection onward, i.e. adding decks from one
collection, not adding collections to one deck, so we only need to add the
association to Collection model:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;schema &amp;quot;collections&amp;quot; do
  field(:name, :string)

  has_many(:decks_collections, DeckCollection, on_replace: :delete)
  has_many(:decks, through: [:decks_collections, :deck], on_replace: :delete)

  timestamps()
end

def changeset(col_or_changeset, attrs) do
  col_or_changeset
  |&amp;gt; cast(attrs, [:name])
  |&amp;gt; cast_assoc(:decks_collections)
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;cast_assoc&lt;/code&gt; in the &lt;code&gt;changeset&lt;/code&gt; function is responsible for creating new or
updating the old relations when in need. And we use &lt;code&gt;has_many&lt;/code&gt; with
&lt;code&gt;on_replace: :delete&lt;/code&gt; to replace all relations at once for that matter.&lt;/p&gt;
&lt;p&gt;If you want to add collections to a deck, define similar associations in the
Deck model.&lt;/p&gt;
&lt;p&gt;The models are all looking good now.&lt;/p&gt;
&lt;h2 id=&#34;the-template&#34;&gt;The template&lt;/h2&gt;
&lt;p&gt;To display current decks in one collection and allow users to edit the
relations, we need two lists of decks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All available decks which can be added to a collection&lt;/li&gt;
&lt;li&gt;All decks which currently belongs to a collection&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;all_decks = Deck
            |&amp;gt; Repo.all()
col_decks = collection.decks
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And in the collection&amp;rsquo;s edit template, we display the relation using checkbox
inputs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;%= for deck &amp;lt;- @all_decks do %&amp;gt;
  &amp;lt;label
    &amp;lt;input
      &amp;lt;%= if Deck.member?(@col_decks, deck), do: &amp;quot;checked&amp;quot; %&amp;gt;
      name=&amp;quot;collection[deck_ids][]&amp;quot;
      type=&amp;quot;checkbox&amp;quot;
      value=&amp;quot;&amp;lt;%= deck.id %&amp;gt;&amp;quot;
    &amp;gt;
    &amp;lt;%= deck.name %&amp;gt;
  &amp;lt;/label&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Data for &lt;code&gt;collection[deck_ids][]&lt;/code&gt; name will become &lt;code&gt;%{&amp;quot;collection&amp;quot; =&amp;gt; %{&amp;quot;deck_ids&amp;quot; =&amp;gt; [1, 2, 3]}}&lt;/code&gt; when pass to controller. And we got the deck IDs we need to keep these
decks in the collection, so in our controller, we got:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def update(conn, %{&amp;quot;collection&amp;quot; =&amp;gt; collection_data, &amp;quot;id&amp;quot; =&amp;gt; collection_id} = _params) do
  decks_collections =
    case collection_data do
      %{&amp;quot;deck_ids&amp;quot; =&amp;gt; deck_ids} -&amp;gt;
        deck_ids
        |&amp;gt; Enum.map(fn dec_id -&amp;gt;
          %{
            &amp;quot;deck_id&amp;quot; =&amp;gt; deck_id,
            &amp;quot;collection_id&amp;quot; =&amp;gt; collection_id,
          }
        end)

      _ -&amp;gt;
        []
    end

  params = %{
    &amp;quot;decks_collections&amp;quot; =&amp;gt; decks_collections
  }

  Collection
  |&amp;gt; Repo.get!(collection_id)
  |&amp;gt; Collection.changeset(params)
  |&amp;gt; Repo.update()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When passing &lt;code&gt;%{&amp;quot;decks_collections&amp;quot; =&amp;gt; [%{&amp;quot;deck_id&amp;quot; =&amp;gt; 1, &amp;quot;collection_id&amp;quot; =&amp;gt; 1}]}&lt;/code&gt; to
&lt;code&gt;changeset&lt;/code&gt; function, Ecto will handle all the hard works for us, following
the rules we have defined before in our models.&lt;/p&gt;
&lt;h2 id=&#34;the-end&#34;&gt;The end&lt;/h2&gt;
&lt;p&gt;That&amp;rsquo;s it. All is done without a single line of JavaScript. Visit
&lt;a href=&#34;https://memoet.com&#34;&gt;memoet.com&lt;/a&gt; and see the Today collection for yourself!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>From Python to Rust, then Elixir</title>
      <link>https://manhtai.github.io/posts/from-python-to-rust-then-elixir/</link>
      <pubDate>Sat, 15 May 2021 09:42:52 +0700</pubDate>
      
      <guid>https://manhtai.github.io/posts/from-python-to-rust-then-elixir/</guid>
      <description>&lt;p&gt;Recently I made &lt;a href=&#34;https://github.com/memoetapp/memoet&#34;&gt;an app&lt;/a&gt; to prepare for some kind of test I have to take.
I would have use &lt;a href=&#34;https://apps.ankiweb.net/&#34;&gt;Anki&lt;/a&gt; for this purpose but I don&amp;rsquo;t want to spend too much
time learing how to make an Anki package again. Instead, I spent much more
time to create a new alternative, but at least I&amp;rsquo;ve learned some things new.&lt;/p&gt;
&lt;h2 id=&#34;1-porting-ankis-supermemo2-from-python-to-rust&#34;&gt;1. Porting Anki&amp;rsquo;s SuperMemo2 from Python to Rust&lt;/h2&gt;
&lt;p&gt;I&amp;rsquo;m not confident enough to launch my own spaced repetition algorithm yet so
I decided to use &lt;a href=&#34;https://www.supermemo.com/archives1990-2015/english/ol/sm2&#34;&gt;SuperMemo2&lt;/a&gt; in a version implemented by Anki desktop app.
The Python code is on &lt;a href=&#34;https://github.com/ankitects/anki/blob/6e954e82a5/pylib/anki/scheduler/v2.py&#34;&gt;one scheduler&lt;/a&gt; file and &lt;a href=&#34;https://github.com/ankitects/anki/blob/6e954e82a5/pylib/tests/test_schedv2.py&#34;&gt;one test&lt;/a&gt; file.&lt;/p&gt;
&lt;p&gt;First thing first, we define an interface which is the core of the algorithm:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; Sched {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next_interval&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self, card: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Card&lt;/span&gt;, choice: &lt;span style=&#34;color:#a6e22e&#34;&gt;Choice&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i64&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;answer_card&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self, card: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Card, choice: &lt;span style=&#34;color:#a6e22e&#34;&gt;Choice&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;Card&lt;/code&gt; contains SuperMemo2&amp;rsquo;s parameters such as queue name, due time, lapses.
&lt;code&gt;Choice&lt;/code&gt; is an enum correspond to the answer we make, from &lt;strong&gt;Forgot&lt;/strong&gt; to &lt;strong&gt;Easy&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;next_interval&lt;/code&gt; shows estimated time to recall the card if we make a choice,
&lt;code&gt;answer_card&lt;/code&gt; is the real action when we make that choice.&lt;/p&gt;
&lt;p&gt;The next following steps are to translate Python functions to Rust methods one by
one. It is quite a smooth process, I feel like I am just adding type annotations
to Python code instead of writing new Rust code. The result is &lt;a href=&#34;https://github.com/memoetapp/memoet/blob/master/native/sm2/src/srs/scheduler.rs&#34;&gt;a new Rust&lt;/a&gt;
file, look quite the same as the old Python one.&lt;/p&gt;
&lt;h2 id=&#34;2-expose-rust-api-to-elixir-phoenix-app&#34;&gt;2. Expose Rust API to Elixir Phoenix app&lt;/h2&gt;
&lt;p&gt;After having myself a spaced repetition package, I need to bring it to life.
To tell the truth, I chose Rust to port to because I know I can import it from
almost anywhere through &lt;a href=&#34;https://doc.rust-lang.org/1.2.0/book/rust-inside-other-languages.html&#34;&gt;Foreign Function Interface&lt;/a&gt; (FFI).&lt;/p&gt;
&lt;p&gt;For no &lt;a href=&#34;https://www.erlang-solutions.com/blog/why-elixir-is-the-programming-language-you-should-learn-in-2020/&#34;&gt;specific reasons&lt;/a&gt;, let&amp;rsquo;s make an Elixir app!&lt;/p&gt;
&lt;p&gt;We use &lt;a href=&#34;https://github.com/rusterlium/rustler&#34;&gt;Rustler&lt;/a&gt; to build the bridge between Rust code and Erlang NIFs. The
setup is quite simple. After some times, we get a new Elixir module with the
APIs we need:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defmodule Memoet.SRS.Sm2 do
  @moduledoc &amp;quot;&amp;quot;&amp;quot;
  Sm2 API, calling Rust code
  When your NIF is loaded, it will override those functions below.
  &amp;quot;&amp;quot;&amp;quot;

  use Rustler, otp_app: :memoet, crate: &amp;quot;sm2&amp;quot;
  alias Memoet.SRS.{Config, Scheduler, Card, Choices}

  @spec new(Config.t(), integer(), integer()) :: Scheduler.t()
  def new(_config, _day_cut_off, _day_today), do: error()

  @spec next_interval(Card.t(), Scheduler.t(), Choices.t()) :: integer()
  def next_interval(_card, _scheduler, _choice), do: error()

  @spec answer_card(Card.t(), Scheduler.t(), Choices.t()) :: Card.t()
  def answer_card(_card, _scheduler, _choice), do: error()
end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another way would work is to compile Rust code to Wasm, and then import it from
anywhere support Wasm runtime.&lt;/p&gt;
&lt;h2 id=&#34;3-summary&#34;&gt;3. Summary&lt;/h2&gt;
&lt;p&gt;Rust is reducing the gap between languages. Maintaining the core logic in Rust
if possible should be considered as a wise choice.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>