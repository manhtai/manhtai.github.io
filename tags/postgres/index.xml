<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Postgres on Go slowly</title>
    <link>https://manhtai.github.io/tags/postgres/</link>
    <description>Recent content in Postgres on Go slowly</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 31 Dec 2021 20:25:07 +0700</lastBuildDate>
    
        <atom:link href="https://manhtai.github.io/tags/postgres/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Update partially and return fully in Go</title>
      <link>https://manhtai.github.io/posts/golang-update-partially-and-return-fully/</link>
      <pubDate>Fri, 31 Dec 2021 20:25:07 +0700</pubDate>
      
      <guid>https://manhtai.github.io/posts/golang-update-partially-and-return-fully/</guid>
      <description>&lt;p&gt;In typical CRUD applications, it&amp;rsquo;s common these days that your update
APIs work properly on objects in a partial way. You should not enforcing
the client to send the whole object to update just a field anymore. And with
Postgres &lt;code&gt;returning&lt;/code&gt; clause, we can return all object data despite being
updated only some of them.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s say you have to update a Student object, we will define all its fields
as pointers so when the client doesn&amp;rsquo;t send up anything, it will be nil:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
      &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the database interface, we will choose the fields that need to update and
return all object data when done, we use &lt;code&gt;pgx&lt;/code&gt; and &lt;code&gt;scany&lt;/code&gt; package here for
executing query and scanning data back to Go struct:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (
      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;os&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;github.com/jackc/pgx/v4&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;github.com/georgysavva/scany/pgxscan&amp;#34;&lt;/span&gt;
)


&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pgx&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Connect&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;context&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Background&lt;/span&gt;(), &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Getenv&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DATABASE_URL&amp;#34;&lt;/span&gt;))

      &lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;      UPDATE students
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;      SET
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          name = CASE WHEN $1 = true THEN $2 ELSE name END,
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          age = CASE WHEN $3 = true THEN $4 ELSE age END
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;      RETURNING
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          name, age`&lt;/span&gt;

      &lt;span style=&#34;color:#a6e22e&#34;&gt;rows&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;conn&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Query&lt;/span&gt;(
         &lt;span style=&#34;color:#a6e22e&#34;&gt;ctx&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;query&lt;/span&gt;,
         &lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;,
         &lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;student&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;
      )
      &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rows&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Close&lt;/span&gt;()

      &lt;span style=&#34;color:#a6e22e&#34;&gt;stud&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Student&lt;/span&gt;{}

      &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rows&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Next&lt;/span&gt;() {
          &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;pgxscan&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ScanRow&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;stud&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;rows&lt;/span&gt;)
      }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Benchmark Postgres Index Performance</title>
      <link>https://manhtai.github.io/posts/benchmark-postgres-index-performance/</link>
      <pubDate>Tue, 02 Nov 2021 14:42:35 +0700</pubDate>
      
      <guid>https://manhtai.github.io/posts/benchmark-postgres-index-performance/</guid>
      <description>&lt;h2 id=&#34;the-question&#34;&gt;The question&lt;/h2&gt;
&lt;p&gt;We had a table contains 150.000 rows and 6 text columns. We do some &lt;code&gt;select&lt;/code&gt;
query using exact match by each of the columns. 150k rows is not too much for
indexing all the 6 columns, right? Let&amp;rsquo;s do a benchmark!&lt;/p&gt;
&lt;h2 id=&#34;the-benchmark&#34;&gt;The benchmark&lt;/h2&gt;
&lt;h3 id=&#34;1-create-table&#34;&gt;1. Create table&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;CREATE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;TABLE&lt;/span&gt; bench &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt;
    md5(random()::text) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; a,
    md5(random()::text) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; b,
    md5(random()::text) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;c&lt;/span&gt;,
    md5(random()::text) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; d,
    md5(random()::text) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; e,
    md5(random()::text) &lt;span style=&#34;color:#66d9ef&#34;&gt;AS&lt;/span&gt; f
&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;
    generate_series(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;150000&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-select-without-index&#34;&gt;2. Select without index&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;select * from bench where a = &amp;#39;a&amp;#39; and b = &amp;#39;b&amp;#39; and c = &amp;#39;c&amp;#39; and d = &amp;#39;d&amp;#39; and e = &amp;#39;e&amp;#39; order by f limit 1;&amp;#34;&lt;/span&gt; | pgbench -d postgres -t &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt; -P &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; -f -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;latency average = 23.562 ms
latency stddev = 0.946 ms
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3-create-index&#34;&gt;3. Create index&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;index&lt;/span&gt; bench_a &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; bench(a);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The way you choose indexes here depends on the cardinality or uniqueness of the data.
We use random data here so one index is enough, and it will perform almost exactly as
when you index all 6 columns!&lt;/p&gt;
&lt;h3 id=&#34;4-select-with-index&#34;&gt;4. Select with index&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;select * from bench where a = &amp;#39;a&amp;#39; and b = &amp;#39;b&amp;#39; and c = &amp;#39;c&amp;#39; and d = &amp;#39;d&amp;#39; and e = &amp;#39;e&amp;#39; order by f limit 1;&amp;#34;&lt;/span&gt; | pgbench -d postgres -t &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt; -P &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; -f -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;latency average = 0.357 ms
latency stddev = 0.354 ms
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;the-answer&#34;&gt;The answer&amp;hellip;&lt;/h2&gt;
&lt;p&gt;&amp;hellip;is yes. Indexing makes your queries 66 times faster!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>